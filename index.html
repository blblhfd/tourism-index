<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÖ®ÁêÉÊÄÅÂäøÊÑüÁü• - BDCSG AI Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
        
        /* Vue App ÂÆπÂô® */
        #app { position: absolute; width: 100%; height: 100%; pointer-events: none; }

        /* Canvas ÂÆπÂô® */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: auto; }

        /* UI Â±Ç (Vue ÊéßÂà∂) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        header { padding: 20px; pointer-events: auto; background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); }
        h1 { margin: 0; font-weight: 300; letter-spacing: 4px; font-size: 28px; background: linear-gradient(90deg, #fff, #00ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 20px rgba(0,255,255,0.3); }
        .subtitle { font-size: 12px; color: #00ffff; text-transform: uppercase; letter-spacing: 2px; }

        /* È¢ÑËßàÈù¢Êùø */
        .preview-panel {
            position: absolute; top: 25%; right: 20px; width: 280px;
            background: rgba(4, 8, 12, 0.9); border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 4px; padding: 20px; color: white;
            transform: translateX(120%); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px); pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
        }
        .preview-panel.active { transform: translateX(0); }

        /* ËØ¶ÊÉÖÈù¢Êùø */
        .detail-panel {
            position: absolute; top: 0; right: 0; 
            width: 80%; height: 100%;
            background: linear-gradient(to left, rgba(4, 8, 12, 1) 15%, rgba(10, 20, 30, 0.98) 100%);
            border-left: 2px solid rgba(0, 255, 255, 0.3);
            transform: translateX(100%); transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            padding: 30px 50px; box-sizing: border-box; pointer-events: auto;
            display: flex; flex-direction: column; 
            backdrop-filter: blur(30px); box-shadow: -50px 0 100px rgba(0,0,0,1);
            overflow: hidden;
        }
        .detail-panel.active { transform: translateX(0); }

        .detail-header { 
            display: flex; justify-content: space-between; align-items: flex-start; 
            margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(0, 255, 255, 0.3); 
            flex-shrink: 0; 
        }
        .country-title { font-size: 56px; color: #fff; text-shadow: 0 0 20px rgba(0, 255, 255, 0.5); margin: -10px 0 5px 0; line-height: 1; }
        .country-meta { font-size: 14px; color: #00aaaa; letter-spacing: 1px; font-family: 'Consolas', monospace; }
        
        .content-layout { display: flex; flex: 1; gap: 40px; overflow: hidden; margin-bottom: 10px; }
        .map-section { flex: 3; display: flex; flex-direction: column; position: relative; }
        .stats-section { flex: 2; overflow-y: auto; padding-right: 10px; display: flex; flex-direction: column; gap: 15px; }

        /* D3 Map */
        #d3-map-wrapper {
            flex: 1; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; position: relative; overflow: hidden;
        }
        .map-controls {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            display: flex; flex-wrap: wrap; gap: 8px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; max-width: 90%;
        }
        .map-btn {
            background: transparent; border: 1px solid #444; color: #aaa;
            padding: 4px 8px; font-size: 11px; cursor: pointer; transition: 0.3s;
        }
        .map-btn:hover, .map-btn.active { background: #00aaaa; color: #000; border-color: #00ffff; box-shadow: 0 0 8px rgba(0,255,255,0.4); }
        
        .map-tooltip {
            position: absolute; bottom: 10px; right: 10px; pointer-events: none;
            background: rgba(0,0,0,0.9); border: 1px solid #00ffff; color: #fff;
            padding: 8px; font-size: 12px; border-radius: 4px; z-index: 20;
        }

        /* Vue List Transition */
        .list-enter-active, .list-leave-active { transition: all 0.5s ease; }
        .list-enter-from, .list-leave-to { opacity: 0; transform: translateX(30px); }

        /* Metric Card */
        .metric-card {
            background: rgba(0, 20, 40, 0.5); border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px 15px; border-radius: 4px; transition: 0.3s; position: relative;
        }
        .metric-card:hover { background: rgba(0, 30, 60, 0.8); border-color: rgba(0, 255, 255, 0.5); }
        
        .metric-header { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .metric-label { color: #ccc; font-size: 12px; text-transform: uppercase; }
        .metric-value { color: #fff; font-size: 18px; font-weight: bold; font-family: 'Consolas', monospace; }
        
        .bar-bg { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.1); border-radius: 3px; overflow: hidden; margin-bottom: 5px; }
        .bar-fill { height: 100%; transition: width 1s cubic-bezier(0.22, 1, 0.36, 1); }
        
        .rank-text { font-size: 12px; color: #888; text-align: right; font-style: italic; }
        .rank-highlight { color: #fff; font-weight: bold; }

        /* AI Section Styles */
        .ai-section {
            margin-top: 10px; border-top: 1px solid rgba(255, 51, 0, 0.3);
            padding-top: 15px; display: flex; flex-direction: column; gap: 10px;
        }
        
        /* ‰∫∫Ê†ºÈÄâÊã©Âô®Ê†∑Âºè */
        .persona-selector { display: flex; gap: 5px; margin-bottom: 5px; }
        .persona-btn {
            flex: 1; background: rgba(0, 0, 0, 0.4); border: 1px solid #444;
            color: #888; padding: 6px 0; font-size: 10px; cursor: pointer;
            transition: 0.3s; text-align: center; font-family: 'Consolas', monospace;
        }
        .persona-btn:hover { border-color: #00ffff; color: #00ffff; }
        
        /* ÈÄâ‰∏≠Áä∂ÊÄÅÔºöÈ¢úËâ≤Âå∫ÂàÜ */
        .persona-btn.active.mode-mean { border-color: #ff3300; color: #ff3300; background: rgba(40, 0, 0, 0.3); }
        .persona-btn.active.mode-pro { border-color: #00aaaa; color: #00aaaa; background: rgba(0, 40, 40, 0.3); }
        .persona-btn.active.mode-boss { border-color: #ffd700; color: #ffd700; background: rgba(40, 40, 0, 0.3); }

        .random-btn { width: 30px; flex: none; font-weight: bold; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); }
        .random-btn:hover { background: #fff; color: #000; }

        .ai-btn {
            background: rgba(40, 0, 0, 0.6); border: 1px solid #ff3300; color: #ff3300;
            padding: 12px; cursor: pointer; font-family: 'Consolas', monospace; text-transform: uppercase;
            letter-spacing: 1px; transition: 0.3s; width: 100%; display: flex; justify-content: space-between; align-items: center;
        }
        .ai-btn:hover:not(:disabled) { background: #ff3300; color: #000; box-shadow: 0 0 15px rgba(255, 51, 0, 0.5); }
        .ai-btn:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; color: #555; }
        
        .ai-response-box {
            background: rgba(10, 0, 0, 0.6); border-left: 2px solid #ff3300;
            padding: 15px; font-size: 13px; color: #ddd; line-height: 1.6;
            animation: fadeIn 0.5s ease; transition: border-color 0.3s;
        }
        /* ÂìçÂ∫îÊ°ÜÈ¢úËâ≤Èöè‰∫∫Ê†ºÂèòÂåñ */
        .ai-response-box.mode-mean { border-left-color: #ff3300; }
        .ai-response-box.mode-pro { border-left-color: #00aaaa; }
        .ai-response-box.mode-boss { border-left-color: #ffd700; }

        .ai-title { color: #ff3300; font-size: 11px; font-weight: bold; margin-bottom: 5px; letter-spacing: 2px; }
        .ai-title.mode-mean { color: #ff3300; }
        .ai-title.mode-pro { color: #00aaaa; }
        .ai-title.mode-boss { color: #ffd700; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .stats-section::-webkit-scrollbar { width: 4px; }
        .stats-section::-webkit-scrollbar-track { background: transparent; }
        .stats-section::-webkit-scrollbar-thumb { background: #005555; }

        .back-btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #aaa;
            padding: 8px 20px; cursor: pointer; margin-bottom: 0; border-radius: 20px; transition: 0.3s;
        }
        .back-btn:hover { border-color: #00ffff; color: #00ffff; background: rgba(0,255,255,0.1); }

        /* Êó∂Èó¥ËΩ¥ */
        .timeline-container {
            position: relative; width: 100%; background: rgba(10, 20, 30, 0.6); 
            border-top: 1px solid rgba(0, 255, 255, 0.3); border-radius: 4px;
            padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 5px;
            flex-shrink: 0; margin-top: auto; 
        }
        .current-date { color: #00ffff; font-size: 20px; font-weight: bold; font-family: 'Consolas', monospace; }
        .time-slider { width: 100%; accent-color: #00ffff; cursor: pointer; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 16px; text-align: center; pointer-events: none;
            background: rgba(0,10,20,0.9); padding: 30px; border: 1px solid #00ffff; 
            box-shadow: 0 0 30px rgba(0,255,255,0.2); z-index: 100;
        }
        
        .legend-container {
            position: absolute; bottom: 10px; right: 10px; 
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 5px; pointer-events: none;
        }
        .legend-bar {
            width: 150px; height: 10px; background: linear-gradient(to right, #f7fbff, #08306b); margin-bottom: 2px;
        }
        .legend-labels { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "d3-geo": "https://cdn.jsdelivr.net/npm/d3-geo@3.1.0/+esm",
                "d3-selection": "https://cdn.jsdelivr.net/npm/d3-selection@3.0.0/+esm",
                "d3-scale": "https://cdn.jsdelivr.net/npm/d3-scale@4.0.2/+esm",
                "d3-scale-chromatic": "https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.0.0/+esm",
                "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2"
            }
        }
    </script>
</head>
<body>
    
    <div id="canvas-container"></div>

    <div id="app">
        
        <div id="loader" v-if="loading">
            Á≥ªÁªüÂàùÂßãÂåñ‰∏≠...<br>
            <span style="font-size:12px; color:#aaa">Ê≠£Âú®Âª∫Á´ãÂÖ®ÁêÉÊï∞ÊçÆÈìæË∑Ø...</span>
            <div style="margin-top:10px; color:#00aaaa">{{ statusText }}</div>
        </div>

        <div id="ui-layer">
            <header>
                <div class="subtitle">GLOBAL INTELLIGENCE SYSTEM</div>
                <h1>ÂÖ®ÁêÉÊÄÅÂäøÊÑüÁü•ÁªàÁ´Ø </h1>
            </header>

            <div class="preview-panel" :class="{ active: showPreview && !detailMode }">
                <div style="font-size:20px; color:#00ffff; margin-bottom:5px;">{{ selectedCountryName }}</div>
                <div style="color:#aaa; font-size:12px; margin-bottom:15px">ISO: <span>{{ selectedIso }}</span></div>
                <div style="min-height: 50px;">ÁÇπÂáªÂú∞ÁêÉÊü•ÁúãÊ¶ÇËßà</div>
                <button style="width:100%; padding:10px; background:rgba(0,255,255,0.2); border:1px solid #00ffff; color:#00ffff; cursor:pointer; margin-top:10px;" 
                        @click="enterDetailMode">ËøõÂÖ•ÊåáÊå•ËßÜÂõæ >></button>
            </div>

            <div class="detail-panel" :class="{ active: detailMode }">
                <div class="detail-header">
                    <div>
                        <h2 class="country-title">{{ selectedCountryName }}</h2>
                        <div class="country-meta">
                            ISO: <span>{{ selectedIso }}</span> | 
                            DATE: <span>{{ currentDate }}</span>
                        </div>
                    </div>
                    <button class="back-btn" @click="exitDetailMode">‚Üê ËøîÂõûÂú∞ÁêÉËßÜÂõæ</button>
                </div>
                
                <div class="content-layout">
                    <div class="map-section">
                        <div class="map-controls">
                            <button v-for="(config, key) in metricConfig" :key="key"
                                    class="map-btn" :class="{ active: currentMetric === key }"
                                    @click="setMapMetric(key)">
                                {{ config.label }}
                            </button>
                        </div>
                        
                        <div id="d3-map-wrapper"></div>
                        
                        <div class="map-tooltip" v-if="mapTooltip.show" :style="{ left: mapTooltip.x + 'px', bottom: mapTooltip.y + 'px' }">
                            {{ mapTooltip.text }}
                        </div>

                        <div class="legend-container">
                            <div class="legend-labels" style="margin-bottom:2px;">
                                <span style="color:#f7fbff; font-weight:bold;">Top 1 (ÊúÄÂ•Ω)</span>
                                <span style="color:#4292c6; font-weight:bold;">Last (ÊúÄÂ∑Æ)</span>
                            </div>
                            <div class="legend-bar"></div>
                            <div style="font-size:10px; color:#888; text-align:center;">È¢úËâ≤Ë∂äÊ∑±ÊéíÂêçË∂äÈù†Âêé | ÁÅ∞Ëâ≤Êó†Êï∞ÊçÆ</div>
                        </div>
                    </div>

                    <div class="stats-section">
                        <div v-if="!countryData" style="color:#aaa; text-align:center; padding-top:50px;">
                            ËØ•ÂõΩÊú¨ÊúàÊó†Êï∞ÊçÆËÆ∞ÂΩï
                        </div>
                        <transition-group name="list" tag="div">
                            <div v-for="item in computedMetrics" :key="item.key" 
                                 class="metric-card" :style="{ borderLeft: '4px solid ' + item.color }">
                                <div class="metric-header">
                                    <span class="metric-label">{{ item.label }}</span>
                                    <span class="metric-value">{{ item.value }}</span>
                                </div>
                                <div class="bar-bg">
                                    <div class="bar-fill" :style="{ width: (100 - item.rankRatio * 100) + '%', background: item.color }"></div>
                                </div>
                                <div class="rank-text">ÂÖ®ÁêÉÊéíÂêç #{{ item.rank }} <span class="rank-highlight" :style="{ color: item.color }">(Top {{ item.topPercent }}%)</span></div>
                            </div>
                        </transition-group>

                        <div class="ai-section" v-if="countryData">
                            
                            <div class="persona-selector">
                                <div v-for="p in PERSONAS" :key="p.id" 
                                     class="persona-btn" 
                                     :class="[p.btnClass, { active: currentPersonaKey === p.id }]"
                                     @click="setPersona(p.id)">
                                    {{ p.label }}
                                </div>
                                <div class="persona-btn random-btn" @click="setRandomPersona" title="ÈöèÊú∫‰∫∫Ê†º">
                                    ?
                                </div>
                            </div>

                            <button class="ai-btn" @click="askAI" :disabled="aiLoading">
                                <span v-if="aiLoading">AI Ê≠£Âú®ËÆ°ÁÆó‰∏≠...</span>
                                <span v-else>
                                    {{ currentPersonaKey === 'mean' ? 'ÁîüÊàêÊØíËàåÂª∫ËÆÆ' : 
                                       currentPersonaKey === 'pro' ? 'Ëé∑Âèñ‰∏ì‰∏öÁÆÄÊä•' : 
                                       'Âê¨Âê¨Èú∏ÊÄªÊÄé‰πàËØ¥' }}
                                </span>
                                <span v-if="!aiLoading">>></span>
                            </button>

                            <div v-if="aiResponse" class="ai-response-box" :class="currentPersonaConfig.btnClass">
                                <div class="ai-title" :class="currentPersonaConfig.btnClass">
                                    {{ currentPersonaConfig.title }}
                                </div>
                                <div class="ai-text">{{ aiResponse }}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="timeline-container">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="color:#aaa; font-size:12px; text-transform:uppercase;">Timeline Control</span>
                        <span class="current-date">{{ currentDate }}</span>
                    </div>
                    <input type="range" class="time-slider" min="0" :max="dateList.length - 1" v-model="dateIndex" @input="onDateInput" @change="onDateChange">
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { createApp, ref, reactive, computed, onMounted } from 'vue';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'three/addons/libs/tween.module.js';
        import { geoContains, geoCentroid, geoEquirectangular, geoPath } from 'd3-geo';
        import { select } from 'd3-selection';
        import { interpolateBlues } from 'd3-scale-chromatic'; 
        import { createClient } from '@supabase/supabase-js';

        // --- 1. ÈÖçÁΩÆ & Â≠óÂÖ∏ ---
        
        // ÂõΩÂÆ∂Ê±âÂåñÂ≠óÂÖ∏
        const COUNTRY_MAP = {
            "United States of America": "ÁæéÂõΩ", "China": "‰∏≠ÂõΩ", "Russia": "‰øÑÁΩóÊñØ", "Ukraine": "‰πåÂÖãÂÖ∞",
            "France": "Ê≥ïÂõΩ", "United Kingdom": "Ëã±ÂõΩ", "Germany": "Âæ∑ÂõΩ", "Japan": "Êó•Êú¨",
            "India": "Âç∞Â∫¶", "South Korea": "Èü©ÂõΩ", "North Korea": "ÊúùÈ≤ú", "Australia": "Êæ≥Â§ßÂà©‰∫ö",
            "Canada": "Âä†ÊãøÂ§ß", "Brazil": "Â∑¥Ë•ø", "Argentina": "ÈòøÊ†πÂª∑", "Mexico": "Â¢®Ë•øÂì•",
            "Italy": "ÊÑèÂ§ßÂà©", "Spain": "Ë•øÁè≠Áâô", "Turkey": "ÂúüËÄ≥ÂÖ∂", "Iran": "‰ºäÊúó",
            "Israel": "‰ª•Ëâ≤Âàó", "Saudi Arabia": "Ê≤ôÁâπÈòøÊãâ‰ºØ", "Egypt": "ÂüÉÂèä", "South Africa": "ÂçóÈùû",
            "Indonesia": "Âç∞Â∫¶Â∞ºË•ø‰∫ö", "Vietnam": "Ë∂äÂçó", "Philippines": "Ëè≤ÂæãÂÆæ", "Thailand": "Ê≥∞ÂõΩ",
            "Malaysia": "È©¨Êù•Ë•ø‰∫ö", "Pakistan": "Â∑¥Âü∫ÊñØÂù¶", "Afghanistan": "ÈòøÂØåÊ±ó", "Syria": "ÂèôÂà©‰∫ö",
            "Iraq": "‰ºäÊãâÂÖã", "Poland": "Ê≥¢ÂÖ∞", "Sweden": "ÁëûÂÖ∏", "Norway": "Êå™Â®Å",
            "Finland": "Ëä¨ÂÖ∞", "Denmark": "‰∏πÈ∫¶", "Netherlands": "Ëç∑ÂÖ∞", "Belgium": "ÊØîÂà©Êó∂",
            "Switzerland": "ÁëûÂ£´", "Austria": "Â••Âú∞Âà©", "Greece": "Â∏åËÖä", "Portugal": "Ëë°ËêÑÁâô",
            "Ireland": "Áà±Â∞îÂÖ∞", "New Zealand": "Êñ∞Ë•øÂÖ∞", "Singapore": "Êñ∞Âä†Âù°", "Myanmar": "ÁºÖÁî∏",
            "Bangladesh": "Â≠üÂä†ÊãâÂõΩ", "Colombia": "Âì•‰º¶ÊØî‰∫ö", "Venezuela": "ÂßîÂÜÖÁëûÊãâ", "Chile": "Êô∫Âà©",
            "Peru": "ÁßòÈ≤Å", "Nigeria": "Â∞ºÊó•Âà©‰∫ö", "Ethiopia": "ÂüÉÂ°û‰øÑÊØî‰∫ö", "Kenya": "ËÇØÂ∞º‰∫ö",
            "Kazakhstan": "ÂìàËê®ÂÖãÊñØÂù¶", "Uzbekistan": "‰πåÂÖπÂà´ÂÖãÊñØÂù¶", "Mongolia": "ËíôÂè§", "Belarus": "ÁôΩ‰øÑÁΩóÊñØ",
            "Hungary": "ÂåàÁâôÂà©", "Czechia": "Êç∑ÂÖã", "Romania": "ÁΩóÈ©¨Â∞º‰∫ö", "Slovakia": "ÊñØÊ¥õ‰ºêÂÖã",
            "Bulgaria": "‰øùÂä†Âà©‰∫ö", "Serbia": "Â°ûÂ∞îÁª¥‰∫ö", "Croatia": "ÂÖãÁΩóÂú∞‰∫ö", "Algeria": "ÈòøÂ∞îÂèäÂà©‰∫ö",
            "Morocco": "Êë©Ê¥õÂì•", "Libya": "Âà©ÊØî‰∫ö", "Sudan": "Ëãè‰∏π", "Yemen": "‰πüÈó®", "Oman": "ÈòøÊõº",
            "United Arab Emirates": "ÈòøËÅîÈÖã", "Qatar": "Âç°Â°îÂ∞î", "Kuwait": "ÁßëÂ®ÅÁâπ"
        };

        const getCNName = (enName) => COUNTRY_MAP[enName] || enName;

        const DB_CONFIG = {
            url: 'https://tqgakltkrgslobwjuvea.supabase.co',
            key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRxZ2FrbHRrcmdzbG9id2p1dmVhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4MDAyMDMsImV4cCI6MjA4MjM3NjIwM30.eeFY0fKmDt1SShUOLlZcslsmuiDu1bxE-hFiriItw6k',
            tableName: 'bdcsg', 
            joinColumn: 'country_code'
        };

        const AI_CONFIG = {
            url: 'https://api2.qiandao.mom/v1/chat/completions',
            key: 'sk-Bdw6Qy5BbWGE6wwnVBUQtbO7urKg5BhUb5TytfW8rDEeWW8N', 
            model: 'gemini-3-pro-preview-h'
        };

        const VISUAL_CONFIG = {
            earthRadius: 5,
            offsetX: -32,
        };

        const METRIC_CONFIG = {
            'conflict_score': { label: 'ÂÜ≤Á™ÅÊåáÊï∞', max: 20, isPositive: false },
            'disaster_score': { label: 'ÁÅæÂÆ≥ÊåáÊï∞', max: 20, isPositive: false },
            'safety_index':   { label: 'ÂÆâÂÖ®ÁªºÊåá', max: 100, isPositive: true },
            'Crime Index':    { label: 'ÁäØÁΩ™ÊåáÊï∞', max: 100, isPositive: false },
            'Safety Index':   { label: '‰∫∫Ë∫´ÂÆâÂÖ®', max: 100, isPositive: true },
            'tone_mean':      { label: 'ËàÜËÆ∫ÂùáÂÄº', max: 10,  isPositive: true },
            'gdelt_event_risk_index': { label: 'GDELTÈ£éÈô©', max: 10, isPositive: false },
            'flu_total_detections': { label: 'ÊµÅÊÑüÁõëÊµã', max: 500, isPositive: false }
        };

        // --- AI Personas ÈÖçÁΩÆ ---
        const PERSONAS = {
            mean: {
                id: 'mean',
                label: 'ÊØíËàåÊ®°Âºè',
                systemPrompt: "‰Ω†ÊòØ‰∏Ä‰∏™ËØ¥ËØùÂàªËñÑ„ÄÅÂπΩÈªò‰∏îÂ∏¶ÊúâÂò≤ËÆΩËØ≠Ê∞îÁöÑAIÊóÖÊ∏∏È°æÈóÆ„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆÊèê‰æõÁöÑÂõΩÂÆ∂ÂÆâÂÖ®Êï∞ÊçÆÔºàÂ¶ÇÂÜ≤Á™ÅÊåáÊï∞„ÄÅÁäØÁΩ™ÁéáÁ≠âÔºâÔºåÁªôÊÉ≥ÂéªËøô‰∏™ÂõΩÂÆ∂ÊóÖÊ∏∏ÁöÑ‰∫∫ÂÜô‰∏ÄÊÆµÁÆÄÁü≠ÁöÑÂª∫ËÆÆÔºà100Â≠óÂ∑¶Âè≥Ôºâ„ÄÇ\n\nËßÑÂàôÔºö\n1. ËØ≠Ê∞îË¶ÅMeanÔºàÂàªËñÑÔºâÔºåÂ∏¶ÁÇπÈªëËâ≤ÂπΩÈªò„ÄÇ\n2. Â¶ÇÊûúÊï∞ÊçÆÂæàÂ∑ÆÔºàÂÜ≤Á™ÅÈ´ò„ÄÅÂÆâÂÖ®‰ΩéÔºâÔºåÂò≤ËÆΩÊ∏∏ÂÆ¢ÊòØ‰∏çÊòØÊ¥ªËÖª‰∫ÜÊÉ≥ÂéªÈÄÅÊ≠ª„ÄÇ\n3. Â¶ÇÊûúÊï∞ÊçÆÂæàÂ•ΩÔºàÂæàÂÆâÂÖ®ÔºâÔºåÂò≤ËÆΩÈÇ£ÈáåÊó†ËÅäÈÄèÈ°∂ÔºåÊàñËÄÖÂò≤ËÆΩÊ∏∏ÂÆ¢Â§™ËÉÜÂ∞èÂè™Êï¢ÂéªËøôÁßçÊ∏©ÂÆ§„ÄÇ\n4. ÂøÖÈ°ªÁªìÂêàÂÖ∑‰ΩìÊï∞ÊçÆËøõË°åÂêêÊßΩ„ÄÇ\n5. ËØ∑Áî®‰∏≠ÊñáÂõûÁ≠î„ÄÇ",
                btnClass: 'mode-mean',
                title: '‚ö†Ô∏è AI RISK ADVISOR (Mean Mode):'
            },
            pro: {
                id: 'pro',
                label: '‰∏ì‰∏öÊ®°Âºè',
                systemPrompt: "‰Ω†ÊòØ‰∏Ä‰ΩçËµÑÊ∑±‰∏î‰∏•Ë∞®ÁöÑÂÖ®ÁêÉÂÆâÂÖ®ÊÉÖÊä•ÂàÜÊûêÂ∏à„ÄÇËØ∑Ê†πÊçÆÊèê‰æõÁöÑÂêÑÈ°πÊåáÊ†áÊï∞ÊçÆÔºåÂÆ¢ËßÇ„ÄÅÂÜ∑ÈùôÂú∞ËØÑ‰º∞ËØ•ÂõΩÁöÑÊóÖË°åÈ£éÈô©„ÄÇËØ∑ÁªôÂá∫ÂàáÂÆûÁöÑÈÅøÈô©Âª∫ËÆÆ„ÄÅÊúÄ‰Ω≥Âá∫Ë°åÊó∂Êú∫ÊàñÂÖ∑‰ΩìÁöÑÂÆâÂÖ®Ê≥®ÊÑè‰∫ãÈ°π„ÄÇËØ≠Ê∞î‰∏ì‰∏ö„ÄÅ‰∏çÂ∏¶ÊÉÖÁª™ÔºåÁÆÄÊòéÊâºË¶ÅÔºåÁõ¥ÂáªÈáçÁÇπÔºà100Â≠óÂ∑¶Âè≥Ôºâ„ÄÇ",
                btnClass: 'mode-pro',
                title: 'üõ°Ô∏è SECURITY BRIEFING (Pro Mode):'
            },
            boss: {
                id: 'boss',
                label: 'Èú∏ÊÄªÊ®°Âºè',
                systemPrompt: "‰Ω†ÊòØ‰∏Ä‰∏™Èú∏ÈÅìÊÄªË£Å„ÄÇ‰Ω†ÁúãÁùÄËøô‰∫õÊï∞ÊçÆÔºåËØ≠Ê∞îÂÇ≤ÊÖ¢„ÄÅËá™‰ø°Ôºå‰ΩÜÂØπÁî®Êà∑Ôºà‰Ω†Âè£‰∏≠ÁöÑ'Â∞èÁ¨®Ëõã'ÔºâÊúâÊûÅÂº∫ÁöÑ‰øùÊä§Ê¨≤„ÄÇÂ¶ÇÊûúÂú∞ÊñπÂç±Èô©ÔºåÈú∏Ê∞îÂú∞ÂëΩ‰ª§Áî®Êà∑‰∏çËÆ∏ÂéªÔºåËØ¥'‰Ω†ÊÉ≥ËÆ©ÊàëÊãÖÂøÉÊ≠ªÂêóÔºü'ÔºõÂ¶ÇÊûúÂÆâÂÖ®ÔºåËØ¥'ËøôÁâáÈ±ºÂ°òÊàë‰∏∫‰Ω†ÊâøÂåÖ‰∫Ü'„ÄÇÁî®ËØçÁÆÄÁü≠ÊúâÂäõÔºåÂøÖÈ°ªÁªìÂêàÊï∞ÊçÆË£ÖÈÖ∑Ôºà100Â≠óÂ∑¶Âè≥Ôºâ„ÄÇ",
                btnClass: 'mode-boss',
                title: 'üíé CEO EXCLUSIVE (Boss Mode):'
            }
        };

        // --- 2. Á±ªÂÆö‰πâ ---

        class D3MapClass {
            constructor(containerId, geoData, tooltipCallback) {
                this.container = document.getElementById(containerId);
                this.geoData = geoData;
                this.tooltipCallback = tooltipCallback;
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
                
                this.init();
                window.addEventListener('resize', this.resize.bind(this));
            }

            init() {
                this.svg = select(this.container).append('svg')
                    .attr('width', '100%').attr('height', '100%');
                this.g = this.svg.append('g');
                this.arrowLayer = this.svg.append('g'); // ÁÆ≠Â§¥Â±Ç
                this.resize();
            }

            resize() {
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
                this.projection = geoEquirectangular().fitSize([this.width, this.height], this.geoData);
                this.pathGenerator = geoPath().projection(this.projection);
                this.svg.selectAll('path').attr('d', this.pathGenerator); 
            }

            render(globalData, selectedIso, metricKey) {
                if (!globalData || !this.pathGenerator) return;

                const config = METRIC_CONFIG[metricKey];
                
                const validItems = globalData
                    .filter(d => d[metricKey] !== null && d[metricKey] !== undefined)
                    .map(d => ({ iso: d[DB_CONFIG.joinColumn], val: d[metricKey] }));
                
                if (config.isPositive) validItems.sort((a, b) => b.val - a.val);
                else validItems.sort((a, b) => a.val - b.val);

                const rankMap = {};
                const total = validItems.length;
                validItems.forEach((item, index) => {
                    const ratio = total > 1 ? index / (total - 1) : 0;
                    rankMap[item.iso] = ratio;
                });

                const valueMap = {};
                validItems.forEach(i => valueMap[i.iso] = i.val);

                const paths = this.g.selectAll('path').data(this.geoData.features);
                
                paths.enter().append('path')
                    .merge(paths)
                    .attr('d', this.pathGenerator)
                    .attr('fill', d => {
                        const iso = d.properties.ISO_A3 || d.properties.ISO_A2 || d.properties.ADM0_A3;
                        const ratio = rankMap[iso];
                        if (ratio === undefined) return '#888888';
                        return interpolateBlues(ratio);
                    })
                    .attr('stroke', '#333')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', (e, d) => {
                        const iso = d.properties.ISO_A3 || d.properties.ISO_A2;
                        const val = valueMap[iso];
                        const cnName = getCNName(d.properties.NAME); // ‰ΩøÁî®‰∏≠ÊñáÂêç
                        this.tooltipCallback({ 
                            show: true, 
                            text: `${cnName}: ${val !== undefined ? val : 'N/A'}`,
                            x: 10, y: 10 
                        });
                        select(e.target).attr('stroke', '#00ffff').attr('stroke-width', 1.5);
                    })
                    .on('mouseout', (e) => {
                        this.tooltipCallback({ show: false });
                        select(e.target).attr('stroke', '#333').attr('stroke-width', 0.5);
                    });
                
                paths.exit().remove();

                // --- ÁªòÂà∂Á∫¢Ëâ≤ÁÆ≠Â§¥ ---
                this.arrowLayer.selectAll('*').remove();
                if (selectedIso) {
                    const feature = this.geoData.features.find(f => {
                        const props = f.properties;
                        return (props.ISO_A3 === selectedIso || props.ISO_A2 === selectedIso || props.ADM0_A3 === selectedIso);
                    });
                    if (feature) {
                        const centroid = this.pathGenerator.centroid(feature);
                        this.arrowLayer.append('path')
                            .attr('d', 'M0,0 L-7,-20 L7,-20 Z') 
                            .attr('transform', `translate(${centroid[0]}, ${centroid[1] - 5})`)
                            .attr('fill', '#ff3300')
                            .attr('stroke', '#ffffff')
                            .attr('stroke-width', 1.5)
                            .attr('class', 'indicator-arrow');
                            
                        this.arrowLayer.append('circle')
                            .attr('cx', centroid[0])
                            .attr('cy', centroid[1])
                            .attr('r', 3)
                            .attr('fill', '#ff3300');
                    }
                }
            }
        }

        class EarthAppClass {
            constructor(container, onSelectCallback) {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer.domElement);

                this.onSelectCallback = onSelectCallback;
                this.earthGroup = new THREE.Group();
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.pointerMesh = null;
                this.pointerFloat = 0;
                this.countriesData = null;

                this.initScene();
                this.animate();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                window.addEventListener('pointerup', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObject(this.earthMesh);
                    
                    if (intersects.length > 0) {
                        const localP = intersects[0].point.clone();
                        this.earthGroup.worldToLocal(localP);
                        const lat = 90 - (Math.acos(localP.y / VISUAL_CONFIG.earthRadius) * 180 / Math.PI);
                        let lon = (Math.atan2(localP.z, -localP.x) * 180 / Math.PI) - 180;
                        if(lon < -180) lon+=360; if(lon > 180) lon-=360;
                        
                        if (this.countriesData) {
                            const found = this.countriesData.features.find(f => geoContains(f, [lon, lat]));
                            this.onSelectCallback(found || null);
                        }
                    }
                });
            }

            initScene() {
                this.camera.position.set(0, 0, 18);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.minDistance = 6.5;
                this.controls.maxDistance = 50;

                this.scene.add(new THREE.AmbientLight(0x404040, 1.5));
                const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
                sunLight.position.set(20, 10, 10);
                this.scene.add(sunLight);

                const loader = new THREE.TextureLoader();
                const mat = new THREE.MeshStandardMaterial({
                    map: loader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg'),
                    bumpMap: loader.load('https://unpkg.com/three-globe/example/img/earth-topology.png'),
                    bumpScale: 0.05, roughness: 0.6, metalness: 0.1
                });
                this.earthMesh = new THREE.Mesh(new THREE.SphereGeometry(VISUAL_CONFIG.earthRadius, 64, 64), mat);
                this.earthGroup.add(this.earthMesh);

                const atmoMat = new THREE.ShaderMaterial({
                    vertexShader: `varying vec3 vNormal; void main() { vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `varying vec3 vNormal; void main() { float i = pow(0.6 - dot(vNormal, vec3(0,0,1)), 4.0); gl_FragColor = vec4(0.2, 0.6, 1.0, 1.0) * i; }`,
                    blending: THREE.AdditiveBlending, side: THREE.BackSide, transparent: true
                });
                this.earthGroup.add(new THREE.Mesh(new THREE.SphereGeometry(VISUAL_CONFIG.earthRadius + 0.25, 64, 64), atmoMat));
                
                const geom = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<4000; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
                geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.scene.add(new THREE.Points(geom, new THREE.PointsMaterial({ size: 0.8, color: 0xffffff, opacity: 0.6, transparent: true })));

                // ÊåáÈíàÊîπ‰∏∫Á∫¢Ëâ≤
                const pGeom = new THREE.ConeGeometry(0.2, 0.8, 16);
                pGeom.rotateX(Math.PI / 2);
                this.pointerMesh = new THREE.Mesh(pGeom, new THREE.MeshBasicMaterial({ color: 0xff3300 })); 
                this.pointerMesh.visible = false;
                this.earthGroup.add(this.pointerMesh);

                this.scene.add(this.earthGroup);
            }

            addGeoData(data) {
                this.countriesData = data;
                const lineMat = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
                const points = [];
                const addPoly = (poly) => {
                    for(let i=0; i<poly.length-1; i++) {
                        const p1 = this.latLonToVec3(poly[i][1], poly[i][0], VISUAL_CONFIG.earthRadius + 0.01);
                        const p2 = this.latLonToVec3(poly[i+1][1], poly[i+1][0], VISUAL_CONFIG.earthRadius + 0.01);
                        points.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
                    }
                };
                data.features.forEach(f => {
                    if(f.geometry.type === 'Polygon') f.geometry.coordinates.forEach(addPoly);
                    else if(f.geometry.type === 'MultiPolygon') f.geometry.coordinates.forEach(m => m.forEach(addPoly));
                });
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                this.earthGroup.add(new THREE.LineSegments(geom, lineMat));
            }

            latLonToVec3(lat, lon, r) {
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                return new THREE.Vector3(-(r * Math.sin(phi) * Math.cos(theta)), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
            }

            moveToDetail(feature) {
                const centroid = geoCentroid(feature);
                const rY = -centroid[0] * (Math.PI / 180) - (Math.PI / 2);
                const rX = centroid[1] * (Math.PI / 180);

                new TWEEN.Tween(this.earthGroup.position).to({ x: VISUAL_CONFIG.offsetX }, 1000).easing(TWEEN.Easing.Cubic.InOut).start();
                new TWEEN.Tween(this.earthGroup.rotation).to({ x: rX, y: rY }, 1000).easing(TWEEN.Easing.Cubic.InOut).start();
                new TWEEN.Tween(this.camera.position).to({ z: 12 }, 1000).easing(TWEEN.Easing.Cubic.InOut).start();
                new TWEEN.Tween(this.controls.target).to({ x: VISUAL_CONFIG.offsetX }, 1000).easing(TWEEN.Easing.Cubic.InOut).start();
                
                const pos = this.latLonToVec3(centroid[1], centroid[0], VISUAL_CONFIG.earthRadius + 0.5);
                this.pointerMesh.position.copy(pos);
                this.pointerMesh.lookAt(new THREE.Vector3(0,0,0));
                this.pointerMesh.visible = true;
            }

            resetView() {
                new TWEEN.Tween(this.earthGroup.position).to({ x: 0 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(this.controls.target).to({ x: 0 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(this.camera.position).to({ z: 18 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(this.earthGroup.rotation).to({ x: 0 }, 1000).start();
                this.pointerMesh.visible = false;
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                TWEEN.update();
                if (this.pointerMesh && this.pointerMesh.visible) {
                    this.pointerFloat += 0.08;
                    this.pointerMesh.translateZ(Math.sin(this.pointerFloat) * 0.004);
                }
                this.renderer.render(this.scene, this.camera);
            }
        }

        // --- 3. Vue Â∫îÁî®ÊåÇËΩΩ ---
        
        createApp({
            setup() {
                // Vue Áä∂ÊÄÅÂÆö‰πâ
                const loading = ref(true);
                const statusText = ref('ËøûÊé•‰∏≠...');
                const detailMode = ref(false);
                const showPreview = ref(false);
                
                const selectedIso = ref('--');
                const selectedCountryName = ref('Country');
                const selectedFeature = ref(null); 
                
                const globalData = ref([]);
                const countryData = ref(null);
                const currentMetric = ref('conflict_score');
                const mapTooltip = reactive({ show: false, text: '', x: 0, y: 0 });

                // AI State
                const aiLoading = ref(false);
                const aiResponse = ref('');
                const currentPersonaKey = ref('mean'); // ÈªòËÆ§ÊØíËàå

                // ËÆ°ÁÆóÂΩìÂâçÈÄâ‰∏≠‰∫∫Ê†ºÁöÑËØ¶ÁªÜÈÖçÁΩÆ
                const currentPersonaConfig = computed(() => PERSONAS[currentPersonaKey.value]);

                // Êó•ÊúüÈÄªËæë
                const dateList = [];
                const startD = new Date(2022, 0, 1);
                const endD = new Date(2025, 11, 1);
                let curr = new Date(startD);
                while(curr <= endD) {
                    dateList.push(`${curr.getFullYear()}/${curr.getMonth() + 1}/1`);
                    curr.setMonth(curr.getMonth() + 1);
                }
                const dateIndex = ref(0);
                const currentDate = ref(dateList[0]);

                const supabase = createClient(DB_CONFIG.url, DB_CONFIG.key);

                // ËÆ°ÁÆóÂ±ûÊÄß
                const computedMetrics = computed(() => {
                    if (!countryData.value) return [];
                    const result = [];
                    for (const [key, config] of Object.entries(METRIC_CONFIG)) {
                        const val = countryData.value[key];
                        if (val !== undefined && val !== null) {
                            const validValues = globalData.value.map(d => d[key]).filter(v => v !== null && v !== undefined);
                            if (config.isPositive) validValues.sort((a,b) => b-a); else validValues.sort((a,b) => a-b);
                            
                            const rank = validValues.indexOf(val) + 1;
                            const total = validValues.length;
                            const rankRatio = total > 1 ? (rank - 1) / (total - 1) : 0;
                            const topPercent = Math.round((rank / total) * 100);
                            
                            result.push({
                                key, label: config.label, value: val, rank, rankRatio, topPercent,
                                color: interpolateBlues(rankRatio)
                            });
                        }
                    }
                    return result;
                });

                // Êï∞ÊçÆËé∑Âèñ
                const fetchGlobalData = async () => {
                    statusText.value = `ÂêåÊ≠•Êï∞ÊçÆ: ${currentDate.value}...`;
                    const { data, error } = await supabase.from(DB_CONFIG.tableName).select('*').eq('report_month', currentDate.value);
                    if (error) { console.error(error); statusText.value = "Êï∞ÊçÆÂêåÊ≠•Â§±Ë¥•"; }
                    else {
                        globalData.value = data || [];
                        statusText.value = "Â∞±Áª™";
                        updateCountryData();
                        if (d3Renderer) d3Renderer.render(globalData.value, selectedIso.value, currentMetric.value);
                    }
                };

                const updateCountryData = () => {
                    if (selectedIso.value !== '--') {
                        countryData.value = globalData.value.find(d => d[DB_CONFIG.joinColumn] === selectedIso.value) || null;
                    }
                };

                // AI Persona Methods
                const setPersona = (key) => {
                    currentPersonaKey.value = key;
                };

                const setRandomPersona = () => {
                    const keys = Object.keys(PERSONAS);
                    const randomKey = keys[Math.floor(Math.random() * keys.length)];
                    currentPersonaKey.value = randomKey;
                };

                // AI Request Function
                const askAI = async () => {
                    if(!countryData.value) return;
                    aiLoading.value = true;
                    aiResponse.value = '';

                    const persona = currentPersonaConfig.value;

                    // ÂáÜÂ§áÂèëÁªôAIÁöÑÊï∞ÊçÆ‰∏ä‰∏ãÊñá
                    const context = computedMetrics.value.map(m => `${m.label}: ${m.value}`).join(', ');

                    try {
                        const res = await fetch(AI_CONFIG.url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${AI_CONFIG.key}`
                            },
                            body: JSON.stringify({
                                model: AI_CONFIG.model,
                                messages: [
                                    {
                                        role: "system",
                                        content: persona.systemPrompt
                                    },
                                    {
                                        role: "user",
                                        content: `ÁõÆÊ†áÂõΩÂÆ∂Ôºö${selectedCountryName.value}„ÄÇ\nÂΩìÂâçÊúà‰ªΩÔºö${currentDate.value}„ÄÇ\nÂêÑÈ°πÊåáÊ†áÊï∞ÊçÆÂ¶Ç‰∏ãÔºö${context}„ÄÇ\nËØ∑ÁªôÂá∫‰Ω†ÁöÑÂª∫ËÆÆ„ÄÇ`
                                    }
                                ]
                            })
                        });

                        const data = await res.json();
                        if(data.choices && data.choices.length > 0) {
                            aiResponse.value = data.choices[0].message.content;
                        } else {
                            aiResponse.value = "AI Ë¢´ÂΩìÂú∞ÂÜõÈòÄÂàáÊñ≠‰∫ÜÁΩëÁ∫ø... (APIËøîÂõûÈîôËØØ)";
                        }
                    } catch (e) {
                        console.error(e);
                        aiResponse.value = "AI ÊãíÁªùËøûÊé•Ôºö‰Ω†ÁöÑËØ∑Ê±ÇË¢´Èò≤ÁÅ´Â¢ôÊã¶Êà™‰∫Ü„ÄÇ";
                    } finally {
                        aiLoading.value = false;
                    }
                };

                const onDateInput = () => { currentDate.value = dateList[dateIndex.value]; };
                const onDateChange = () => { fetchGlobalData(); };
                const setMapMetric = (key) => {
                    currentMetric.value = key;
                    if (d3Renderer) d3Renderer.render(globalData.value, selectedIso.value, currentMetric.value);
                };

                const enterDetailMode = () => {
                    if (!selectedFeature.value) return;
                    detailMode.value = true;
                    showPreview.value = false;
                    aiResponse.value = ''; // Reset AI when entering
                    if (earthApp) earthApp.moveToDetail(selectedFeature.value);
                    setTimeout(() => {
                         if(d3Renderer) {
                             d3Renderer.resize();
                             d3Renderer.render(globalData.value, selectedIso.value, currentMetric.value);
                         }
                    }, 100);
                };

                const exitDetailMode = () => {
                    detailMode.value = false;
                    aiResponse.value = ''; // Reset AI when exiting
                    if (earthApp) earthApp.resetView();
                };

                let earthApp = null;
                let d3Renderer = null;

                onMounted(async () => {
                    // ÂàùÂßãÂåñ Three.js
                    earthApp = new EarthAppClass(document.getElementById('canvas-container'), (feature) => {
                        if (detailMode.value) return; 
                        if (feature) {
                            selectedFeature.value = feature;
                            // Ê±âÂåñÂ§ÑÁêÜ
                            selectedCountryName.value = getCNName(feature.properties.NAME);
                            selectedIso.value = feature.properties.ISO_A3 || feature.properties.ISO_A2 || "UNK";
                            showPreview.value = true;
                            updateCountryData();
                        } else {
                            showPreview.value = false;
                        }
                    });

                    try {
                        const res = await fetch('https://cdn.jsdelivr.net/gh/nvkelso/natural-earth-vector@master/geojson/ne_110m_admin_0_countries.geojson');
                        const geoData = await res.json();
                        earthApp.addGeoData(geoData);
                        d3Renderer = new D3MapClass('d3-map-wrapper', geoData, (tooltip) => { Object.assign(mapTooltip, tooltip); });
                        loading.value = false;
                        fetchGlobalData();
                    } catch (e) {
                        console.error(e);
                        statusText.value = "Âú∞ÂõæÂä†ËΩΩÂ§±Ë¥•";
                    }
                });

                return {
                    loading, statusText, detailMode, showPreview, selectedIso, selectedCountryName,
                    currentDate, dateList, dateIndex, onDateInput, onDateChange,
                    metricConfig: METRIC_CONFIG, currentMetric, setMapMetric, countryData, computedMetrics, mapTooltip,
                    enterDetailMode, exitDetailMode,
                    // AI Exports
                    askAI, aiLoading, aiResponse, 
                    PERSONAS, currentPersonaKey, setPersona, setRandomPersona, currentPersonaConfig
                };
            }
        }).mount('#app');
    </script>
</body>
</html>